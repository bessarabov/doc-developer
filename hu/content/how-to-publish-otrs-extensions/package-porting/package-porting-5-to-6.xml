<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<section id="package-porting-5-to-6">
    <title>OTRS 5-ről 6-ra</title>
    <para>
        Ez a szakasz azokat a változtatásokat sorolja fel, amelyeket meg kell
vizsgálnia, amikor átírja a csomagját az OTRS 5-ről 6-ra.
    </para>

    <section id="package-porting-5-to-6-datetime">
        <title>Dátum- és időszámítás</title>
        <para>
            Az OTRS 6-ban egy új modul lett hozzáadva a dátum- és időszámításhoz:
<literal>Kernel::System::DateTime</literal>. A
<literal>Kernel::System::Time</literal> modul mostantól elavult, és többé
nem szabad használni új kódoknál.
        </para>
        <para>
            Az új <literal>Kernel::System::DateTime</literal> modul legfőbb előnye, hogy
támogatja a valódi időzónákat (mint például
<literal>Europe/Berlin</literal>) az órákban számított időeltolások (mint
például <literal>+2</literal>) helyett. Ne feledje, hogy a régi
<literal>Kernel::System::Time</literal> modult is továbbfejlesztették az
időzónák támogatásához. Az időeltolások teljes mértékben eldobásra
kerültek. Ez azt jelenti, hogy az összes olyan kódot, amely időeltolásokat
használ a számításokhoz, át kell írni az új <literal>DateTime</literal>
modul használatához. Azok a kódok, amelyek önmaguk nem foglalkoznak az
időeltolásokkal, a legtöbb esetben maradhatnak érintetlenül. Mindössze arról
kell meggyőződnie, hogy a <literal>Kernel::System::Time</literal> objektum
létrehozásakor érvényes időzóna legyen megadva.
        </para>
        <para>
            Itt egy példa az időeltolásos kód időzónákra történő átírásához:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
# Feltételezzünk egy 0 időeltolást ennél az objektumnál.
my $TimeObject     = $Kernel::OM->Get('Kernel::System::Time');
my $SystemTime     = $TimeObject->TimeStamp2SystemTime( String => '2004-08-14 22:45:00' );
# Általában beállításon vagy paraméteren keresztül van lekérve.
my $UserTimeZone   = '+2';
my $UserSystemTime = $SystemTime + $UserTimeZone * 3600;
my $UserTimeStamp  = $TimeObject->SystemTime2TimeStamp( SystemTime => $UserSystemTime );
            ]]></programlisting>
        </para>
        <para>
            Az új <literal>Kernel::System::DateTime</literal> modult használó kód:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
# Ez hallgatólagosan beállítja a beállított OTRS időzónát.
my $DateTimeObject = $Kernel::OM->Create('Kernel::System::DateTime');
# Általában beállításon vagy paraméteren keresztül van lekérve.
my $UserTimeZone   = 'Europe/Berlin';
$DateTimeObject->ToTimeZone( TimeZone => $UserTimeZone );
# Ne feledje, hogy az epoch független az időzónától, mindig az UTC-hez lesz kiszámítva.
my $SystemTime    = $DateTimeObject->ToEpoch();
my $UserTimeStamp = $DateTimeObject->ToString();
            ]]></programlisting>
        </para>
        <para>
            Ne feledje, hogy a <literal>Kernel::System::DateTime</literal> modulban lévő
új <code>Get()</code> függvénnyel visszaadott időértékek vezető nulla nélkül
lesznek a <literal>Kernel::System::Time</literal> modulban lévő
<code>SystemTime2Date()</code> függvény által visszaadottak helyett. Az új
<literal>Kernel::System::DateTime</literal> modulban a <code>Format()</code>
függvény szövegként adja vissza a dátumot és időt a megadott formátum
szerint.
        </para>
    </section>

    <section id="package-porting-5-to-6-user-multiupload">
        <title>A fogd és vidd többszörös feltöltés hozzáadása</title>
        <para>
            Az OTRS 6-nál egy több mellékletet feltöltő funkcionalitás lett
hozzáadva. Ahhoz, hogy a több melléklet feltöltését megvalósítsa az egyéb
kiterjesztésekben, a melléklet rész, valamint a
<code>JSOnDocumentComplete</code> részek eltávolítása szükséges a
sablonfájlokból (<literal>AttachmentDelete</literal> és
<literal>AttachmentUpload</literal>). Tartsa észben, hogy néhány esetben a
JavaScript részek már kihelyezésre kerültek a
<filename>Core.Agent.XXX</filename> fájlokba.
        </para>
        <note>
            <para>
                Ne feledje, hogy ez jelenleg csak olyan helyeknél alkalmazható, ahol
tulajdonképpen van értelme a több fájl feltöltési lehetőségének (mint
például <literal>AgentTicketPhone</literal>,
<literal>AgentTicketCompose</literal>, stb.). Ez nem használható mindenféle
beállítás nélkül az adminisztrátori képernyőknél.
            </para>
        </note>
        <para>
            Ahhoz, hogy az új több melléklet feltöltést tartalmazza a sablon, cserélje
le a meglévő <code>input type="file"</code> elemet a következő kódra a
<filename>.tt</filename> sablonfájlban:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
<label>[% Translate("Attachments") | html %]:</label>
<div class="Field">
[% INCLUDE "FormElements/AttachmentList.tt" %]
</div>
<div class="Clear"></div>
            ]]></programlisting>
        </para>
        <para>
            Az is szükséges, hogy eltávolítsa az <code>IsUpload</code> változót és az
összes egyéb <code>IsUpload</code> részt a Perl-modulból. Az olyan kódrészek
nem szükségesek többé, mint a következők:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $IsUpload = ( $ParamObject->GetParam( Param => 'AttachmentUpload' ) ? 1 : 0 );
            ]]></programlisting>
        </para>
        <para>
            Ezenkívül a melléklet megjelenítő blokkot is le kell cserélni:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
$LayoutObject->Block(
    Name => 'Attachment',
    Data => $Attachment,
);
            ]]></programlisting>
        </para>
        <para>
            Cserélje le erre a kódra:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
push @{ $Param{AttachmentList} }, $Attachment;
            ]]></programlisting>
        </para>
        <para>
            Ha a modul, ahová integrálni szeretné a többszörös feltöltést, támogatja a
szabványos sablonokat, akkor győződjön meg arról, hogy hozzáadott-e egy
szakaszt az ember által olvasható fájlméret formátumok megjelenítéséhez
közvetlenül azután, hogy a kiválasztott sablon melléklete be lett töltve
(nézze meg az <literal>AgentTicketPhone</literal> modult hivatkozásként):
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
for my $Attachment (@TicketAttachments) {
    $Attachment->{Filesize} = $LayoutObject->HumanReadableDataSize(
        Size => $Attachment->{Filesize},
    );
}
            ]]></programlisting>
        </para>
        <para>
            Mikor Selenium egységteszteket ad az átírt modulokhoz, akkor vessen egy
pillantást a <filename>Selenium/Agent/MultiAttachmentUpload.t</filename>
fájlra hivatkozásként.
        </para>
    </section>

    <section id="packge-porting-5-to-6-admin-modules">
        <title>Az adminisztrációs képernyők továbbfejlesztései</title>

        <section id="packge-porting-5-to-6-breadcrumbs">
            <title>Kenyérmorzsák hozzáadása az adminisztrációs képernyőkhöz</title>
            <para>
                Az OTRS 6-ban az összes adminisztrációs modulnak tartalmaznia kell egy
kenyérmorzsát. A kenyérmorzsát csak a <filename>.tt</filename> sablonfájlban
kell hozzáadni, és közvetlenül a h1 címsor után kell elhelyezni a fájl felső
részén. Ezenkívül a címsornak meg kell kapnia az <code>InvisibleText</code>
osztályt, hogy csak a képernyőfelolvasóknak legye
<emphasis>láthatóvá</emphasis>.
            </para>
            <programlisting format="linespecific"><![CDATA[
<div class="MainBox ARIARoleMain LayoutFixedSidebar SidebarFirst">
    <h1 class="InvisibleText">[% Translate("Name of your module") | html %]</h1>
[% BreadcrumbPath = [
        {
            Name => Translate('Name of your module'),
        },
    ]
%]
[% INCLUDE "Breadcrumb.tt" Path = BreadcrumbPath %]
...
            ]]></programlisting>
            <para>
                Győződjön meg arról, hogy hozzáadta-e a megfelelő kenyérmorzsát az
adminisztrációs modul összes szintjéhez (például
<literal>Subaction</literal>):
            </para>
            <programlisting format="linespecific"><![CDATA[
[% BreadcrumbPath = [
        {
            Name => Translate('Module Home Screen'),
            Link => Env("Action"),
        },
        {
            Name => Translate("Some Subaction"),
        },
    ]
%]

[% INCLUDE "Breadcrumb.tt" Path = BreadcrumbPath %]
                ]]></programlisting>
        </section>

        <section id="package-porting-5-to-6-saveandcontinue">
            <title><emphasis>Mentés</emphasis> és <emphasis>Mentés és befejezés</emphasis>
gombok hozzáadása az adminisztrációs képernyőkhöz</title>
            <para>
                Az OTRS 6-ban az adminisztrációs modulok nemcsak egy
<emphasis>Mentés</emphasis> gombot tartalmaznak, hanem egy <emphasis>Mentés
és befejezés</emphasis> gombot is. A <emphasis>Mentés</emphasis> gombnak
ugyanazon a szerkesztőoldalon kell hagynia a felhasználót mentés után, míg a
<emphasis>Mentés és befejezés</emphasis> gombnak vissza kell vinnie annak az
entitásnak az áttekintőjére, amin a felhasználó jelenleg dolgozik. Nézze meg
a meglévő OTRS adminisztrációs képernyőit hivatkozásként.
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
<div class="Field SpacingTop SaveButtons">
    <button class="Primary CallForAction" id="SubmitAndContinue" type="submit" value="[% Translate("Save") | html %]"><span>[% Translate("Save") | html %]</span></button>
    [% Translate("or") | html %]
    <button class="Primary CallForAction" id="Submit" type="submit" value="[% Translate("Save") | html %]"><span>[% Translate("Save and finish") | html %]</span></button>
    [% Translate("or") | html %]
    <a href="[% Env("Baselink") %]Action=[% Env("Action") %]"><span>[% Translate("Cancel") | html %]</span></a>
</div>
                ]]></programlisting>
            </para>
        </section>
    </section>

    <section id="packge-porting-5-to-6-configuration-files">
        <title>Beállítófájlok költöztetése</title>

        <section id="package-porting-5-to-6-XML-config-file-format">
            <title>XML beállítófájl formátum</title>
            <para>
                Az OTRS 6 egy új <link linkend="xml-config">XML beállítófájl
formátumot</link> használ, és a beállítófájlok helye áthelyezésre került a
<filename>Kernel/Config/Files</filename> mappából a
<filename>Kernel/Config/Files/XML</filename> mappába. A meglévő XML
beállítófájloknak az új formátumra és helyre történő átalakításához
használhatja a következő eszközt, amely az OTRS keretrendszer része:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
bin/otrs.Console.pl Dev::Tools::Migrate::ConfigXMLStructure --source-directory Kernel/Config/Files
Migrating configuration XML files...
Kernel/Config/Files/Calendar.xml -> Kernel/Config/Files/XML/Calendar.xml... Done.
Kernel/Config/Files/CloudServices.xml -> Kernel/Config/Files/XML/CloudServices.xml... Done.
Kernel/Config/Files/Daemon.xml -> Kernel/Config/Files/XML/Daemon.xml... Done.
Kernel/Config/Files/Framework.xml -> Kernel/Config/Files/XML/Framework.xml... Done.
Kernel/Config/Files/GenericInterface.xml -> Kernel/Config/Files/XML/GenericInterface.xml... Done.
Kernel/Config/Files/ProcessManagement.xml -> Kernel/Config/Files/XML/ProcessManagement.xml... Done.
Kernel/Config/Files/Ticket.xml -> Kernel/Config/Files/XML/Ticket.xml... Done.

Done.
                ]]></programlisting>
            </para>
        </section>

        <section id="package-porting-5-to-6-perl-config-file-format">
            <title>Perl beállítófájl formátum</title>
            <para>
                Az OTRS 6 felgyorsítja a beállítófájlok betöltését a régi beállítási
formátum (1) támogatásának eldobásával, amely csak egymás utáni Perl kódot
használ, és az <literal>eval</literal> által kellett futtatni, és ehelyett
kényszerítve az új csomagalapú formátumot (1.1) a Perl beállítófájloknál. Az
OTRS 6+ csak az ebben a formátumban lévő fájlokat tudja betölteni, ezért
győződjön meg arról, hogy átalakította-e az összes egyéni fejlesztést erre
(lásd <filename>Kernel/Config/Files/ZZZ*.pm</filename> például). Minden
egyes Perl beállítófájlnak tartalmaznia kell egy csomagot a
<literal>Load()</literal> metódussal.
            </para>
            <para>
                Régebben a Perl beállítófájlokat néha rossz célra használták egy automatikus
betöltő mechanizmusként a meglévő csomagokban lévő kód felülírásához. Ez
többé nem szükséges, mivel az OTRS 6 biztosít egy dedikált
<literal>Autoload</literal> mechanizmust. Nézze meg a
<filename>Kernel/Autoload/Test.pm</filename> fájlt annak bemutatásához, hogy
hogyan kell használni ezt a mechanizmust egy metódus hozzáadásához egy
meglévő fájlba.
            </para>
        </section>
    </section>

    <section id="package-porting-5-to-6-perldoc-structure">
        <title>Megváltoztatott Perl-dokumentáció szerkezet</title>
        <para>
            A Perl-fájlokban lévő POD szerkezete kis mértékben javítva lett, és
alkalmazni kell az összes fájlban. A POD mostantól kényszerítve van, hogy
szintaktikailag helyes legyen.
        </para>
        <para>
            Amit korábban <literal>SYNOPSIS</literal> szakasznak hívtak, azt most
<literal>DESCRIPTION</literal> névre változtatták, mivel a szinopszis
jellemzően néhány népszerű kódhasználati példát biztosít, és nem magának a
modulnak a leírását. Természetesen megadható további szinopszis. Itt egy
példa arra, hogy hogyan:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
=head1 NAME

Kernel::System::ObjectManager - Központi egyke kezelő és objektumpéldány előállító

=head1 SYNOPSIS

# Csak felső szintű parancsfájlokban!
local $Kernel::OM = Kernel::System::ObjectManager->new();

# Bárhol: egyke példány lekérése (és létrehozása, ha szükséges).
my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

# Egyke objektumok és az összes függőségük eltávolítása.
$Kernel::OM->ObjectsDiscard(
    Objects            => ['Kernel::System::Ticket', 'Kernel::System::Queue'],
);

=head1 DESCRIPTION

Az objektumkezelő egy központi hely az egyke OTRS objektumok létrehozásához
és hozzáféréséhez (a C<L</Get()>> metóduson keresztül), valamint szabályos
(nem kezelt) objektumpéldányok létrehozásához (a C<L</Create()>> metóduson
keresztül).

            ]]></programlisting>
        </para>
        <para>
            Abban az esetben, ha a <literal>DESCRIPTION</literal> nem ad hozzá semmilyen
értéket a <literal>NAME</literal> szakaszban lévő sorhoz, akkor át kell írni
vagy teljesen el kell távolítani.
        </para>
        <para>
            A második fontos változtatás, hogy a függvények mostantól
<literal>=head2</literal> szakaszként vannak dokumentálva a korábban
használt <literal>=item</literal> helyett.
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
=head2 Get()

Lekér egy egyke objektumot, és ha még nem létezik, akkor a háttérben létrehoz egyet.

my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

# Második meghíváskor visszaadja ugyanazt a ConfigObject objektumot, mint ami fent van.
my $ConfigObject2 = $Kernel::OM->Get('Kernel::Config');

=cut

sub Get { ... }
            ]]></programlisting>
        </para>
        <para>
            Ezek a változtatások egy továbbfejlesztett internetes API dokumentációhoz
vezetnek, amint az objektumkezelő dokumentációjában is látható az <ulink
url="http://otrs.github.io/doc/api/otrs/5.0/Perl/Kernel/System/ObjectManager.pm.html">OTRS
5</ulink> és az <ulink
url="http://otrs.github.io/doc/api/otrs/6.0/Perl/Kernel/System/ObjectManager.pm.html">OTRS
6</ulink> esetén.
        </para>
    </section>

    <section id="package-porting-javascript-templating-improvements">
        <title>Továbbfejlesztések a sablonozáshoz és a JavaScript használatával végzett
munkához</title>

        <section id="package-porting-5-to-6-javascript-refactor">
            <title>A JavaScript eltávolításra került a sablonokból</title>
            <para>
                Az OTRS 6-tal az összes JavaScript - különösen a
<literal>JSOnDocumentComplete</literal> blokkokban lévők - eltávolításra
kerültek a sablonfájlokból, és át lettek helyezve JavaScript fájlokba. Csak
nagyon ritka feltételek esetén szükséges a JavaScript kódot a sablonfájlokon
belül elhelyezni. Minden egyéb előfordulásnál tegye a JS kódot a modulra
jellemző JavaScript fájlokba. Az ilyen JavaScript fájlokban lévő
<literal>Init()</literal> metódus automatikusan végre lesz hajtva a fájl
betöltésekor (az eseménykötések előkészítéséhez, stb.), ha regisztrálja a
JavaScript fájlt az OTRS alkalmazásban. Ezt a
<literal>Core.Init.RegisterNamespace(TargetNS, 'APP_MODULE');</literal>
végrehajtásával lehet elvégezni a névtér meghatározásának végén a JavaScript
fájlon belül.
            </para>
        </section>

        <section id="package-porting-5-to-6-richtext-template">
            <title>A sablonfájlok eltávolításra kerültek a Rich Text szerkesztőből</title>
            <para>
                A sablonfájlokon belül lévő JavaScript újraírása mellett (lásd fent) a Rich
Text szerkesztő (<literal>RichTextEditor.tt</literal> és
<literal>CustomerRichTextEditor.tt</literal>) sablonfájljai is eltávolításra
kerültek, mivel azok többé nem szükségesek.
            </para>
            <para>
                Általában ezek a sablonfájlok voltak megtalálhatók a modulra jellemző
sablonfájlokban egy blokkon belül:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
[% RenderBlockStart("RichText") %]
[% InsertTemplate("RichTextEditor.tt") %]
[% RenderBlockEnd("RichText") %]
                ]]></programlisting>
            </para>
            <para>
                Erre többé nincs szükség, és eltávolítható. Ahelyett, hogy meghívná ezt a
blokkot a Perl-modulból, mostantól szükség van a szükséges Rich Text
paraméter beállítására ott. Ahelyett, hogy:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$LayoutObject->Block(
    Name => 'RichText',
    Data => \%Param,
);
                ]]></programlisting>
            </para>
            <para>
                mostantól ezt kell meghívnia:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$LayoutObject->SetRichTextParameters(
    Data => \%Param,
);
                ]]></programlisting>
            </para>
            <para>Ugyanez a szabály alkalmazható az ügyfélfelületre is. Távolítsa el a Rich
Text blokkokat a <filename>CustomerRichTextEditor.tt</filename> fájlból, és
inkább a következő kódot alkalmazza:</para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$LayoutObject->CustomerSetRichTextParameters(
    Data => \%Param,
);
                ]]></programlisting>
            </para>
        </section>

        <section id="package-porting-5-to-6-javascript-translations">
            <title>Fordítások a JavaScript fájlokban</title>
            <para>
                A lefordítható szövegek hozzáadása a JavaScript fájlokban eléggé nehéz volt
az OTRS-ben. A szöveget le kellett fordítani a Perl-modulban vagy a
sablonban, majd ezután kellett átküldeni a JavaScript függvénynek. Az OTRS
6-tal a szövegek lefordítása közvetlenül a JavaScript fájlokban
lehetséges. Az összes egyéb kerülőmegoldást el kell távolítani, különösen a
csak a sablonokban lévő, a szövegek lefordításához használt blokkokat.
            </para>
            <para>
                Ehelyett az új <literal>Core.Language</literal> JavaScript fordítási
névteret kell használni a szövegek lefordításához közvetlenül a JavaScript
fájlokban:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
Core.Language.Translate('The string to translate');
                ]]></programlisting>
            </para>
            <para>
                Lehetséges továbbá JavaScript változókat átadni, amelyek ki lesznek cserélve
közvetlenül a szövegben:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
Core.Language.Translate('The %s to %s', 'string', 'translate');
                ]]></programlisting>
            </para>
            <para>
                Minden egyes <literal>%s</literal> helykitöltő a további paraméterként
átadott változóval lesz kicserélve. A paraméterek száma nincs korlátozva.
            </para>
        </section>

        <section id="package-porting-5-to-6-javascript-handover">
            <title>Adatok átadása Perlből JavaScriptbe</title>
            <para>
                A sablonfájlok JavaScript kód nélküli eléréséhez néhány egyéb
kerülőmegoldást is meg kellett tenni a megfelelő megoldáshoz. A fordítások
mellett az adatok átadása a Perlből a JavaScriptbe továbbra is probléma az
OTRS-ben. A kerülőmegoldás az volt, hogy egy JavaScript blokkot adtak a
sablonba, amelyben a JavaScript változók meg lettek határozva és fel lettek
töltve a sablon címkéivel a Perlből a sablonba átadott adatok alapján.
            </para>
            <para>
                Az adatok Perlből JavaScriptbe történő átadásának folyamata mostantól sokkal
egyszerűbb az OTRS 6-ban. Ahhoz, hogy bizonyos adatokat változóként küldjön
át a Perlből a JavaScriptbe, valakinek csak egy függvényt kell meghívnia a
Perl oldalon. Ezután az adatok automatikusa elérhetők lesznek a
JavaScriptben.
            </para>
            <para>
                A Perlben csak ezt kell meghívni:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$Self->{LayoutObject}->AddJSData(
    Key   => 'KeyToBeAvailableInJS',
    Value => $YourData,
);
                ]]></programlisting>
            </para>
            <para>
                A <literal>Value</literal> paraméter automatikusan át lesz alakítva JSON
objektummá, és tartalmazhat összetett adatokat is.
            </para>
            <para>
                A JavaScriptben az adatokat ezzel kaphatja meg:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
Core.Config.Get('KeyToBeAvailableInJS');
            ]]></programlisting>
            </para>
            <para>
                Ez felváltja az összes kerülőmegoldást, amiket el kell távolítani egy modul
OTRS 6-ra történő átírásakor, mert a sablonfájlokban lévő JavaScript
mostantól csak nagyon ritka feltételek esetén engedélyezett (lást fent).
            </para>
        </section>

        <section id="package-porting-5-to-6-javascript-templates">
            <title>HTML sablonok a JavaScripthez</title>
            <para>
                Az OTRS 6 egy új JavaScript API-t vezet be a
<literal>Core.Template</literal> osztályon keresztül. Hasonló módon
használhatja a JavaScript kódjában mint ahogy a
<literal>TemplateToolkit</literal> modult használta a Perl kódból.
            </para>
            <para>
                Itt egy példa a meglévő <literal>jQuery</literal> alapú kód átírásához az új
sablon API-ra:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
var DivID = 'MyDiv',
    DivText = 'Helló, Világ!';

$('<div />').addClass('CSSClass')
    .attr('id', DivID)
    .text(DivText)
    .appendTo('body');
                ]]></programlisting>
            </para>
            <para>
                Először győződjön meg arról, hogy létrehozott-e egy új sablonfájlt a
<literal>Kernel/Output/JavaScript/Templates/Standard</literal> mappa
alatt. Ehhez a következőket kell észben tartania:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Hozzon létre egy almappát a <literal>Modulja</literal> nevével.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Újrahasználhatja a meglévő almappa szerkezetet, de csak akkor, ha van
értelme a komponensénél (például <literal>Agent/SajatModul/</literal> vagy
<literal>Agent/Admin/SajatModul/</literal>).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Használjon <literal>.html.tmpl</literal> kiterjesztést a sablonfájlnál.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Tömören és világosan nevezze el a sablonokat annak érdekében, hogy elkerülje
a félreértéseket (például jó:
<literal>Agent/SajatModul/SettingsDialog.html.tmpl</literal>, rossz:
<literal>Agent/SettingsDialogTemplate.html.tmpl</literal>).
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Ezután adja hozzá a HTML-t a sablonfájlhoz, meggyőződve arról, hogy
helykitöltőket használ minden olyan változónál, amire szüksége lehet:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
<div id="{{ DivID }}" class="CSSClass">
    {{ DivText | Translate }}
</div>
                ]]></programlisting>
            </para>
            <para>
                Majd egyszerűen jeleníttesse meg a HTML-t a
<literal>Core.Template.Render</literal> metódusnak a sablon elérési útjával
(kiterjesztés nélkül) és a változókat tartalmazó objektummal való
meghívásával a helyettesítéshez:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
var DivHTML = Core.Template.Render('Agent/MyModule/SettingsDialog', {
    DivID: 'MyDiv',
    DivText: 'Helló, Világ!'
});

$(DivHTML).appendTo('body');
                ]]></programlisting>
            </para>
            <para>
                Belsőleg a <literal>Core.Template</literal> a Nunjucks motort használja a
sablonok feldolgozásához. Lényegében bármilyen érvényes Nunjucks szintaxis
támogatott, nézze meg a <ulink
url="https://mozilla.github.io/nunjucks/templating.html">dokumentációjukat</ulink>
a további információkért.
            </para>
            <para>
                Itt van néhány tipp:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Használhatja a <literal>| Translate</literal> szűrőt a szövegek
lefordításához az aktuális nyelvre.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Az összes <literal>{{ VarName }}</literal> változókimenet alapértelmezetten
HTML elfedésben részesített. Ha valamilyen meglévő HTML-t szeretne kiíratni,
akkor használja a <literal>| safe</literal> szűrőt az elfedés
megkerüléséhez.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Használja az <literal>| urlencode</literal> szűrőt az URL paramétereinek
kódolásához.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            A helyettesítő objektumban lévő összetett szerkezetek is támogatottak,
szóval nyugodtan átadhat tömböket vagy kivonatokat, és végiglépkedhet rajtuk
közvetlenül a sablonban. Például nézze meg a <literal>{% for %}</literal>
szintaxist a <ulink
url="https://mozilla.github.io/nunjucks/templating.html#for">Nunjucks
dokumentációjában</ulink>.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>

    </section>

    <section id="package-porting-5-to-6-user-permissions">
        <title>Felhasználói jogosultságok ellenőrzése</title>
        <para>
            Az OTRS 6 előtt a felhasználói jogosultságok a munkamenetben voltak
eltárolva és attribútumként lettek átadva a <code>LayoutObject</code>
objektumnak, amely viszont ezután hozzáfért a meghatározott felhasználói
jogosultságokhoz, mint például <code>if
($LayoutObject->{'UserIsGroup[admin]'}) { ... }</code>.
        </para>
        <para>
            Az OTRS 6-tal a jogosultságok többé nincsenek a munkamenetben eltárolva, és
nem kerülnek átadásra a <code>LayoutObject</code> objektumnak sem. Cserélje
ki a kódjában, hogy a <code>PermissionCheck()</code> metódust hívja meg a
<code>Kernel::System::Group</code> modulon (ügyintézőknél) vagy a
<code>Kernel::System::CustomerGroup</code> modulon (ügyfeleknél). Itt egy
példa:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $HasPermission = $Kernel::OM->Get('Kernel::System::Group')->PermissionCheck(
UserID    => $UserID,
GroupName => $GroupName,
Type      => 'move_into',
);
            ]]></programlisting>
        </para>
    </section>

    <section id="package-porting-5-to-6-ticket-api">
        <title>Jegy API változások</title>

        <section id="package-porting-5-to-6-ticket-api-ticketget">
            <title><literal>TicketGet()</literal></title>
            <para>
                Az OTRS 6-nál az összes kiterjesztést ellenőrizni kell, és át kell írni a
<literal>$Ticket{SolutionTime}</literal> értékről
<literal>$Ticket{Closed}</literal> értékre, ha a
<literal>TicketGet()</literal> az <literal>Extended</literal> paraméterrel
lett meghívva (nézze meg a <ulink
url="https://bugs.otrs.org/show_bug.cgi?id=11872">11872</ulink>-s hibát).
            </para>
            <para>
                Ezenkívül a <literal>ticket.create_time_unix</literal> adatbázisoszlop
eltávolításra került, és hasonlóképpen a <literal>CreateTimeUnix</literal>
érték is el lett távolítva a <literal>TicketGet()</literal> eredményeként
kapott adatokból. Használja helyette a <literal>Created</literal> értéket
(<literal>ticket.create_time</literal> adatbázisoszlop).
            </para>
        </section>

        <section id="package-porting-5-to-6-ticket-api-linkobject-events">
            <title><literal>LinkObject</literal> események</title>
            <para>
                Az OTRS 6-ban a régi, jegyekre jellemző <literal>LinkObject</literal>
események el lettek dobva:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>TicketSlaveLinkAdd</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>TicketSlaveLinkDelete</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>TicketMasterLinkDelete</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Ehelyett az ezekre figyelő összes eseménykezelőt át kell írni az két új
eseményre:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>LinkObjectLinkAdd</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>LinkObjectLinkDelete</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Ezek az új események mindig aktiválva lesznek, amikor egy kapcsolatot
hozzáad vagy töröl a <literal>LinkObject</literal>, tekintet nélkül az
objektum típusára. A <literal>Data</literal> paraméter tartalmazni fogja az
összes információt, amire az eseménykezelőjének szüksége lehet a további
feldolgozáshoz, például:
            </para>
            <para>
                <variablelist>
                    <varlistentry>
                        <term><literal>SourceObject</literal></term>
                        <listitem>
                            <para>
                                A kapcsolat forrásobjektumának neve (például <literal>Ticket</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>SourceKey</literal></term>
                        <listitem>
                            <para>
                                A kapcsolat forrásobjektumának kulcsa (például <literal>TicketID</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>TargetObject</literal></term>
                        <listitem>
                            <para>
                                A kapcsolat célobjektumának neve (például <literal>FAQItem</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>TargetKey</literal></term>
                        <listitem>
                            <para>
                                A kapcsolat célobjektumának kulcsa (például <literal>FAQItemID</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Type</literal></term>
                        <listitem>
                            <para>
                                A kapcsolat típusa (például <literal>ParentChild</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>State</literal></term>
                        <listitem>
                            <para>
                                A kapcsolat állapota (<literal>Valid</literal> vagy
<literal>Temporary</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                Ezekkel az új eseményekkel az egyéni <literal>LinkObject</literal> modulra
jellemző bármely esemény megvalósításai eldobhatók, és az összes
eseménykezelő átírható ezek használatára helyette. Mivel a forrás- és a
célobjektumnevek magában az eseményben is meg vannak adva, magától értetődő
lehet, hogy csak különleges helyzetekben legyenek futtatva.
            </para>
            <para>
                Ahhoz, hogy az eseménykezelőt regisztrálja ezekhez az új eseményekhez,
győződjön meg arról, hogy hozzáadott-e egy regisztrációt a beállításokhoz,
például:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
<!-- OLD STYLE -->
<ConfigItem Name="LinkObject::EventModulePost###1000-SampleModule" Required="0" Valid="1">
    <Description Translatable="1">Event handler for sample link object module.</Description>
    <Group>Framework</Group>
    <SubGroup>Core::Event::Package</SubGroup>
    <Setting>
        <Hash>
            <Item Key="Module">Kernel::System::LinkObject::Event::SampleModule</Item>
            <Item Key="Event">(LinkObjectLinkAdd|LinkObjectLinkDelete)</Item>
            <Item Key="Transaction">1</Item>
        </Hash>
    </Setting>
</ConfigItem>

<!-- NEW STYLE -->
<Setting Name="LinkObject::EventModulePost###1000-SampleModule" Required="0" Valid="1">
    <Description Translatable="1">Event handler for sample link object module.</Description>
    <Navigation>Core::Event::Package</Navigation>
    <Value>
        <Hash>
            <Item Key="Module">Kernel::System::LinkObject::Event::SampleModule</Item>
            <Item Key="Event">(LinkObjectLinkAdd|LinkObjectLinkDelete)</Item>
            <Item Key="Transaction">1</Item>
        </Hash>
    </Value>
</Setting>
                ]]></programlisting>
            </para>
        </section>
    </section>

    <section id="package-porting-5-to-6-article-api">
        <title>Bejegyzés API változások</title>
        <para>
            Az OTRS 6-ban változások történtek a bejegyzés API-n az új <emphasis>Omni
Channel</emphasis> infrastruktúra előkészítéséhez.
        </para>

        <section id="otrs6-article-methods">
            <title>Metabejegyzés API</title>
            <para>
                A bejegyzés objektum mostantól olyan felső szintű bejegyzésfüggvényeket
biztosít, amelyek nem vonják be a háttérprogramhoz kapcsolódó adatokat.
            </para>
            <para>
                A következő, bejegyzésre vonatkozó metódusok át lettek helyezve a
<literal>Kernel::System::Ticket::Article</literal> objektumba:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                          <para><literal>ArticleFlagSet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleFlagDelete()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleFlagGet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleFlagsOfTicketGet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleAccountedTimeGet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleAccountedTimeDelete()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleSenderTypeList()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleSenderTypeLookup()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>SearchStringStopWordsFind()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>SearchStringStopWordsUsageWarningActive()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Ha hivatkozik ezen metódusok bármelyikére a
<literal>Kernel::System::Ticket</literal> objektumon keresztül a kódjában,
akkor váltson át a bejegyzés objektum használatára helyette. Például:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
    my $ArticleObject = $Kernel::OM->Get('Kernel::System::Ticket::Article');

    my %ArticleSenderTypeList = $ArticleObject->ArticleSenderTypeList();
                ]]></programlisting>
            </para>
            <para>
                Az új <literal>ArticleList()</literal> metódust mostantól a bejegyzés
objektum biztosítja, és bejegyzések felsorolásához és kereséséhez
használható. Ez a metódus szűrőket és bejegyzésszámozást valósít meg,
valamint a bejegyzés metaadatait csak rendezett listaként adja
vissza. Például:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my @Articles = $ArticleObject->ArticleList(
    TicketID             => 123,
    CommunicationChannel => 'Email',            # elhagyható, korlátozás egy bizonyos kommunikációs csatornára
    SenderType           => 'customer',         # elhagyható, korlátozás egy bizonyos bejegyzés küldőtípusra
    IsVisibleForCustomer => 1,                  # elhagyható, korlátozás egy bizonyos láthatóságra
    OnlyFirst            => 1,                  # elhagyható, csak az első egyezést adja vissza, vagy
    OnlyLast             => 1,                  # elhagyható, csak az utolsó egyezést adja vissza
);
                ]]></programlisting>
            </para>
            <para>
                A következő, bejegyzésekre vonatkozó metódusok mindegyike el lett dobva. Ha
ezek közül bármelyiket használja a kódjában, akkor értékelje ki az
alternatívák lehetőségeit.
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                          <para>
                              <literal>ArticleFirstArticle()</literal> (használja az <literal>ArticleList(
OnlyFirst => 1 )</literal> metódust helyette)
                          </para>
                    </listitem>
                    <listitem>
                          <para>
                              <literal>ArticleLastCustomerArticle()</literal> (használja az
<literal>ArticleList( SenderType => 'customer', OnlyLast => 1 )</literal>
metódust vagy hasonlót)
                          </para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleCount()</literal> (használja az
<literal>ArticleList()</literal> metódust helyette)</para>
                    </listitem>
                    <listitem>
                          <para>
                              <literal>ArticlePage()</literal> (újraírva az
<literal>AgentTicketZoom</literal> modulban)
                          </para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleTypeList()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleTypeLookup()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleIndex()</literal> (használja az
<literal>ArticleList()</literal> metódust helyette)</para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleContentIndex()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                A bejegyzésadatokkal való munkához használja az új bejegyzés háttérprogram
API-t. A bejegyzés megfelelő háttérprogram-objektumának lekéréséhez
használja a következőt:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                          <para><literal>BackendForArticle(%Article)</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>BackendForChannel( ChannelName => $ChannelName )</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                A <literal>BackendForArticle()</literal> visszaadja a megfelelő
háttérprogramot egy adott bejegyzésnél vagy az érvénytelen háttérprogramot
azért, hogy mindig számíthasson egy háttérprogram-objektum példányra,
amelyet használhat sorozatos hívásoknál.
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my $ArticleBackendObject = $ArticleObject->BackendForArticle( TicketID => 42, ArticleID => 123 );
                ]]></programlisting>
            </para>
            <para>
                A <literal>BackendForChannel()</literal> visszaadja a megfelelő
háttérprogramot egy adott kommunikációs csatornánál.
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my $ArticleBackendObject = $ArticleObject->BackendForChannel( ChannelName => 'Email' );
                ]]></programlisting>
            </para>
        </section>

        <section id="package-porting-5-to-6-article-backend-api">
            <title>Bejegyzés háttérprogram API</title>
            <para>
                Az összes többi bejegyzésadat és a hozzájuk kapcsolódó metódus át lett
helyezve külön háttérprogramokba. Minden egyes kommunikációs csatorna
mostantól rendelkezik egy dedikált háttérprogram API-val, amely kezeli a
bejegyzésadatokat és használható azok manipulálásához.
            </para>
            <para>
                Az OTRS 6 Free néhány alapértelmezett csatornával és a megfelelő
háttérprogramokkal érkezik:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>E-mail (egyenértékű a régi <literal>email</literal> bejegyzéstípusokkal)</para>
                    </listitem>
                    <listitem>
                        <para>Telefon (egyenértékű a régi <literal>phone</literal> bejegyzéstípusokkal)</para>
                    </listitem>
                    <listitem>
                        <para>Belső (egyenértékű a régi <literal>note</literal> bejegyzéstípusokkal)</para>
                    </listitem>
                    <listitem>
                        <para>Csevegés (egyenértékű a régi <literal>chat</literal> bejegyzéstípusokkal)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <note>
                <para>
                    Miközben a csevegés bejegyzés háttérprogram elérhető az OTRS 6 Free
verziójában, csak akkor használható, ha a rendszer érvényes <emphasis
role="bold">OTRS Business Solution™</emphasis> telepítéssel rendelkezik.
                </para>
            </note>
            <para>
                A bejegyzés adatainak manipulálása a következő háttérprogram-metódusokon
keresztül végezhető el:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>ArticleCreate()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleUpdate()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleGet()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleDelete()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Ezen metódusok mindegyikéből el lett dobva a bejegyzéstípus paraméter,
amelyet a <literal>SenderType</literal> és az
<literal>IsVisibleForCustomer</literal> paraméterek kombinációjával kell
helyettesíteni. Ezenkívül mostantól ezen metódusok mindegyike igényli a
<literal>TicketID</literal> és a <literal>UserID</literal> paramétereket.
            </para>
            <note>
                <para>
                    Mivel a bejegyzés API-ban lévő változások rendszerszintűek, a régi API-t
használó összes kódot át kell írni az OTRS 6-hoz. Ebbe beletartozik például
az összes webszolgáltatás meghatározás, amely kihasználja ezeket a
metódusokat közvetlenül az általános felületen keresztül. Ezeket újra meg
kell vizsgálni és hozzá kell igazítani ahhoz, hogy az összes szükséges
paramétert biztosítsák az új API-hoz a kérések közben, és kezeljék a rájuk
adott válaszokat az új formátumban.
                </para>
            </note>
            <para>
                Ne feledje, hogy az <literal>ArticleGet()</literal> visszatérési kivonata
megváltozott, és néhány dolog (mint például a jegyadatok)
hiányozhatnak. Használja a <literal>DynamicFields => 1</literal> és a
<literal>RealNames => 1</literal> paramétereket, hogy további információ
kapjon.
            </para>
            <para>
                Ezenkívül a melléklet adatai többé nem lesznek visszaadva, használja a
következő metódusok kombinációját a bejegyzés háttérprogramokból:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>ArticleAttachmentIndex()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleAttachment()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Ne feledje, hogy az <literal>ArticleAttachmentIndex()</literal> paraméterei
és működése is megváltozott. A régi paraméterdarabok helyett használja az új
<literal>ExcludePlainText</literal>, <literal>ExcludeHTMLBody</literal> és
<literal>ExcludeInline</literal> kombinációját.
            </para>
            <para>
                Példaként itt van, hogy az összes bejegyzés- és mellékletadatot hogyan lehet
lekérni ugyanabban a kivonatban:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my @Articles = $ArticleObject->ArticleList(
    TicketID => $TicketID,
);

ARTICLE:
for my $Article (@Articles) {

    # Győződjön meg arról, hogy lekérte-e a háttérprogram-objektumot ehhez a bizonyos bejegyzéshez.
    my $ArticleBackendObject = $ArticleObject->BackendForArticle( %{$Article} );

    my %ArticleData = $ArticleBackendObject->ArticleGet(
        %{$Article},
        DynamicFields => 1,
        UserID        => $UserID,
    );
    $Article = \%ArticleData;

    # Mellékletindex lekérése (mellékletek nélkül).
    my %AtmIndex = $ArticleBackendObject->ArticleAttachmentIndex(
        ArticleID => $Article->{ArticleID},
        UserID    => $UserID,
    );
    next ARTICLE if !%AtmIndex;

    my @Attachments;
    ATTACHMENT:
    for my $FileID ( sort keys %AtmIndex ) {
        my %Attachment = $ArticleBackendObject->ArticleAttachment(
            ArticleID => $Article->{ArticleID},
            FileID    => $FileID,
            UserID    => $UserID,
        );
        next ATTACHMENT if !%Attachment;

        $Attachment{FileID} = $FileID;
        $Attachment{Content} = encode_base64( $Attachment{Content} );

        push @Attachments, \%Attachment;
    }

    # Mellékletadatok felvétele a bejegyzés kivonatába.
    $Article->{Atms} = \@Attachments;
}
                ]]></programlisting>
            </para>
        </section>
        <section id="package-porting-5-to-6-article-search-index">
            <title>Bejegyzéskeresési index</title>
            <para>
                A bejegyzésindexelés általánosabbá tételéhez a bejegyzés háttérprogramok
mostantól biztosítják a bejegyzésadatok megfelelő indexeléséhez  szükséges
információkat. Az index hasonlóan lesz létrehozva a régi
<literal>StaticDB</literal> mechanizmushoz, és egy dedikált
bejegyzéskeresési táblában lesznek eltárolva.
            </para>
            <para>
                Mivel mostantól minden egyes bejegyzés háttérprogram képes keresést
biztosítani a bejegyzés mezőinek tetszőleges számán, használja a
<literal>BackendSearchableFieldsGet()</literal> metódust a velük kapcsolatos
információk lekéréséhez. Ezek az adatok használhatók a kérések formázásánál
is a <literal>TicketSearch()</literal> metódushoz. Véletlenül néhány
<literal>TicketSearch()</literal> paraméter megváltoztatta a nevét, hogy
tartalmazza a bejegyzés háttérprogram információit is, például:
            </para>
            <para>
                <informaltable>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Régi paraméter</entry>
                                <entry>Új paraméter</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><literal>From</literal></entry>
                                <entry><literal>MIMEBase_From</literal></entry>
                            </row>
                            <row>
                                <entry><literal>To</literal></entry>
                                <entry><literal>MIMEBase_To</literal></entry>
                            </row>
                            <row>
                                <entry><literal>Cc</literal></entry>
                                <entry><literal>MIMEBase_Cc</literal></entry>
                            </row>
                            <row>
                                <entry><literal>Subject</literal></entry>
                                <entry><literal>MIMEBase_Subject</literal></entry>
                            </row>
                            <row>
                                <entry><literal>Body</literal></entry>
                                <entry><literal>MIMEBase_Body</literal></entry>
                            </row>
                            <row>
                                <entry><literal>AttachmentName</literal></entry>
                                <entry><literal>MIMEBase_AttachmentName</literal></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>
                Ezenkívül a bejegyzéskeresési indexelés mostantól aszinkron hívásban lesz
végrehajtva annak érdekében, hogy kitegye az index kiszámítását egy
különálló feladatba. Míg ez rendben van a produktív rendszereknél, aközben
új problémákat hozhat létre bizonyos helyzetekben, például
egységteszteknél. Ha kézzel hozza létre a bejegyzéseket az egységtesztben,
és arra számít, hogy azonnal kereshető lesz a létrehozás után, akkor
győződjön meg arról, hogy meghívta-e kézzel az új
<literal>ArticleSearchIndexBuild()</literal> metódust a bejegyzésobjektumon.
            </para>
        </section>
    </section>
    <section id="package-porting-5-to-6-sysconfig-changes">
        <title>Rendszerbeállítás API változások</title>
        <para>
            Ne feledje, hogy az OTRS 6-ban a rendszerbeállítások API megváltozott, ezért
ellenőriznie kell, hogy a metódusok léteznek-e még. Például a
<literal>ConfigItemUpdate()</literal> el lett távolítva. A helyettesítéshez
a következő metódusok kombinációját kell használnia:
        </para>
        <para>
            <itemizedlist>
                <listitem>
                    <para><literal>SettingLock()</literal></para>
                </listitem>
                <listitem>
                    <para><literal>SettingUpdate()</literal></para>
                </listitem>
                <listitem>
                    <para><literal>ConfigurationDeploy()</literal></para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            Abban az esetben, ha frissíteni szeretne egy konfigurációs beállítást egy
csomag <literal>CodeInstall</literal> szakasza közben, akkor használhatja a
<literal>SettingsSet()</literal> metódust. Ez elvégzi a korábban említett
összes lépést, és használható egyszerre több beállításnál is.
        </para>
        <note>
            <para>Ne használja a <literal>SettingSet()</literal> metódust magán a
rendszerbeállítás grafikus felhasználói felületén.</para>
        </note>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $Success = $SysConfigObject->SettingsSet(
    UserID   => 1,                                      # (kötelező) Felhasználó-azonosító.
    Comments => 'Üzembe állítási megjegyzés.',          # (elhagyható) Megjegyzés.
    Settings => [                                       # (kötelező) Frissítendő beállítások listája.
        {
            Name                   => 'Setting::Name',  # (kötelező)
            EffectiveValue         => 'Value',          # (elhagyható)
            IsValid                => 1,                # (elhagyható)
            UserModificationActive => 1,                # (elhagyható)
        },
        ...
    ],
);
            ]]></programlisting>
        </para>
    </section>
    <section id="package-porting-5-to-6-linkobject-changes">
        <title><literal>LinkObject</literal> API változások</title>
        <para>
            Ne feledje, hogy a <literal>LinkObject</literal> kissé módosult az OTRS
6-ban, valamint a <literal>LinkList()</literal> és a
<literal>LinkKeyList()</literal> metódusok különböző eredményt adhatnak
vissza, ha a <literal>Direction</literal> paramétert használják. Fontolja
meg a <literal>Direction</literal> paraméter megváltoztatását.
        </para>
        <para>
            Régi kód:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $LinkList = $LinkObject->LinkList(
    Object    => 'Ticket',
    Key       => '321',
    Object2   => 'FAQ',
    State     => 'Valid',
    Type      => 'ParentChild',
    Direction => 'Target',
    UserID    => 1,
);
            ]]></programlisting>
        </para>
        <para>
            Új kód:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $LinkList = $LinkObject->LinkList(
    Object    => 'Ticket',
    Key       => '321',
    Object2   => 'FAQ',
    State     => 'Valid',
    Type      => 'ParentChild',
    Direction => 'Source',
    UserID    => 1,
);
            ]]></programlisting>
        </para>
    </section>
    <section id="package-porting-5-to-6-postmaster-filter-communication-log">
        <title>Kommunikációs napló támogatás a további levelezési szűrőkhöz</title>
        <para>
            Az OTRS 6 e-mail kezelési továbbfejlesztésének részeként egy új naplózó
mechanizmus lett hozzáadva az OTRS 6-hoz, kifejezetten a bejövő és kimenő
kommunikációk használatához. Az összes levelezési szűrő fel lett javítva
ezzel az új <link linkend="log-mechanism-communication-log">kommunikációs
napló</link> API-val, amely azt jelenti, hogy a csomagokkal érkező bármely
további szűrő is kihasználhatja az új naplózási funkciót.
        </para>
        <para>
            Ha a csomagja további levelezési szűrőket valósít meg, akkor győződjön meg
arról, hogy megismerje az <link
linkend="log-mechanism-communication-log">API használati
utasításokat</link>. Kap egy példát is azzal kapcsolatban, hogy ezt a
naplózási mechanizmust hogyan kell megvalósítani, ha belenéz a
<literal>Kernel::System::PostMaster::NewTicket</literal> kódjába.
        </para>
    </section>

    <section id="package-porting-5-to-6-process-mailqueue-for-ut">
        <title>Levelezési sor feldolgozása az egységtesztekhez</title>
        <para>
            Az OTRS 6 e-mail kezelési továbbfejlesztésének részeként az összes e-mail
mostantól aszinkron módon lesz elküldve, amely azt jelenti, hogy egy
várakozási sorba lesznek elmentve a későbbi feldolgozáshoz.
        </para>
        <para>
            Ahhoz, hogy az e-mailektől függő egységtesztek továbbra is megfelelően
működjenek, az e-mail várakozási sor feldolgozásának kényszerítése
szükséges.
        </para>
        <para>
            Győződjön meg arról, hogy egy tiszta várakozási sorral indul:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                $MailQueueObject->Delete();
            ]]></programlisting>
        </para>
        <para>
            Ha néhány esetben nem tudja teljesen kitakarítani a várakozási sort (például
Selenium egységteszteknél), akkor egyszerűen törölje azokat az elemeket,
amelyek a tesztek során jöttek létre:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                my %MailQueueCurrentItems = map { $_->{ID} => $_ } @{ $MailQueueObject->List() || [] };

                my $Items = $MailQueueObject->List();
                MAIL_QUEUE_ITEM:
                for my $Item ( @{$Items} ) {
                    next MAIL_QUEUE_ITEM if $MailQueueCurrentItems{ $Item->{ID} };
                    $MailQueueObject->Delete(
                        ID => $Item->{ID},
                    );
                }
            ]]></programlisting>
        </para>
        <para>
            Dolgozza fel a várakozási sort azután a kód után, amely várhatóan elküldi az
e-maileket:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                my $QueueItems      = $MailQueueObject->List();
                for my $Item ( @{$QueueItems} ) {
                    $MailQueueObject->Send( %{$Item} );
                }
            ]]></programlisting>
        </para>
        <para>
            Vagy csak azokat dolgozza fel, amelyek a tesztek során jöttek létre:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                my $QueueItems      = $MailQueueObject->List();
                MAIL_QUEUE_ITEM:
                for my $Item ( @{$QueueItems} ) {
                    next MAIL_QUEUE_ITEM if $MailQueueCurrentItems{ $Item->{ID} };
                    $MailQueueObject->Send( %{$Item} );
                }
            ]]></programlisting>
        </para>
        <para>
            Az esettől függően esetleg ki kell takarítania a várakozási sort a
feldolgozása után vagy előtt.
        </para>
    </section>

    <section id="package-porting-5-to-6-agentticketzoom-widget-handling">
        <title>Felületi elem kezelés a jegynagyítás képernyőn</title>
        <para>
            A jegynagyítás képernyőn lévő felületi elemek továbbfejlesztésre kerültek,
hogy általánosabb módon működjenek. Az OTRS 6-tal mostantól lehetőség van új
felületi elemek hozzáadására a jegynagyítás képernyőhöz a
rendszerbeállításokon keresztül. Lehetőség van beállítani a használt modult,
a felületi elem helyzetét (például oldalsáv) és hogy a tartalmat szinkron
módon (alapértelmezett) vagy AJAX kérésen keresztül kell betölteni.
        </para>
        <para>
            Itt egy beállítási példa az alapértelmezett felületi elemekhez:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
<Setting Name="Ticket::Frontend::AgentTicketZoom###Widgets###0100-TicketInformation" Required="0" Valid="1">
    <Description Translatable="1">AgentTicketZoom widget that displays ticket data in the side bar.</Description>
    <Navigation>Frontend::Agent::View::TicketZoom</Navigation>
    <Value>
        <Hash>
            <Item Key="Module">Kernel::Output::HTML::TicketZoom::TicketInformation</Item>
            <Item Key="Location">Sidebar</Item>
        </Hash>
    </Value>
</Setting>
<Setting Name="Ticket::Frontend::AgentTicketZoom###Widgets###0200-CustomerInformation" Required="0" Valid="1">
    <Description Translatable="1">AgentTicketZoom widget that displays customer information for the ticket in the side bar.</Description>
    <Navigation>Frontend::Agent::View::TicketZoom</Navigation>
    <Value>
        <Hash>
            <Item Key="Module">Kernel::Output::HTML::TicketZoom::CustomerInformation</Item>
            <Item Key="Location">Sidebar</Item>
            <Item Key="Async">1</Item>
        </Hash>
    </Value>
</Setting>
            ]]></programlisting>
        </para>
        <note>
            <para>
                Ezzel a változtatással a felületi elem kódjában lévő sablonblokkok
eltávolításra kerültek, ezért ellenőriznie kell, ha a régi felületi elem
blokkokat használja néhány kimeneti szűrőben a
<literal>Frontend::Template::GenerateBlockHooks</literal> funkcionalitáson
keresztül, és meg kell valósítania az új módszer szerint.
            </para>
        </note>
    </section>
</section>
