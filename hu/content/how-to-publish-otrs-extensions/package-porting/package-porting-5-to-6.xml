<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<section id="package-porting-5-to-6">
    <title>From OTRS 5 to 6</title>
    <para>
        This section lists changes that you need to examine when porting your
package from OTRS 5 to 6.
    </para>

    <section id="package-porting-5-to-6-datetime">
        <title>Date and time calculation</title>
        <para>
            In OTRS 6, a new module for date and time calculation was added:
<literal>Kernel::System::DateTime</literal>. The module
<literal>Kernel::System::Time</literal> is now deprecated and should not be
used for new code anymore.
        </para>
        <para>
            The main advantage of the new <literal>Kernel::System::DateTime</literal>
module is the support for real time zones like
<literal>Europe/Berlin</literal> instead of time offsets in hours like
<literal>+2</literal>. Note that also the old
<literal>Kernel::System::Time</literal> module has been improved to support
time zones. Time offsets have been completely dropped. This means that any
code that uses time offsets for calculations has to be ported to use the new
<literal>DateTime</literal> module instead. Code that doesn't fiddle around
with time offsets itself can be left untouched in most cases. You just have
to make sure that upon creation of a <literal>Kernel::System::Time</literal>
object a valid time zone will be given.
        </para>
        <para>
            Here's an example for porting time offset code to time zones:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $TimeObject     = $Kernel::OM->Get('Kernel::System::Time'); # Assume a time offset of 0 for this time object
my $SystemTime     = $TimeObject->TimeStamp2SystemTime( String => '2004-08-14 22:45:00' );
my $UserTimeZone   = '+2'; # normally retrieved via config or param
my $UserSystemTime = $SystemTime + $UserTimeZone * 3600;
my $UserTimeStamp  = $TimeObject->SystemTime2TimeStamp( SystemTime => $UserSystemTime );
            ]]></programlisting>
        </para>
        <para>
            Code using the new <literal>Kernel::System::DateTime</literal> module:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $DateTimeObject = $Kernel::OM->Create('Kernel::System::DateTime'); # This implicitly sets the configured OTRS time zone
my $UserTimeZone   = 'Europe/Berlin'; # normally retrieved via config or param
$DateTimeObject->ToTimeZone( TimeZone => $UserTimeZone );
my $SystemTime    = $DateTimeObject->ToEpoch(); # note that the epoch is independent from the time zone, it's always calculated for UTC
my $UserTimeStamp = $DateTimeObject->ToString();
            ]]></programlisting>
        </para>
        <para>
            Please note that the returned time values with the new <code>Get()</code>
function in the <literal>Kernel::System::DateTime</literal> module are
without leading zero instead of the old <code>SystemTime2Date()</code>
function in the <literal>Kernel::System::Time</literal> module.  In the new
<literal>Kernel::System::DateTime</literal> module the function
<code>Format()</code> returns the date/time as string formatted according to
the given format.
        </para>
    </section>

    <section id="package-porting-5-to-6-user-multiupload">
        <title>Adding the drag &amp; drop multiupload</title>
        <para>
            For OTRS 6, a multi attachment upload functionality was added. To implement
the multi attachment upload in other extensions it is necessary to remove
the attachment part from the template file, also the
<code>JSOnDocumentComplete</code> parts (<literal>AttachmentDelete</literal>
and <literal>AttachmentUpload</literal>). Please keep in mind, in some cases
the JavaScript parts are already outsourced in
<filename>Core.Agent.XXX</filename> files.
        </para>
        <note>
            <para>
                Please note that this is currently only applicable for places where it
actually makes sense to have the possibility to upload multiple files (like
<literal>AgentTicketPhone</literal>, <literal>AgentTicketCompose</literal>,
etc.). This is not usable out of the box for admin screens.
            </para>
        </note>
        <para>
            To include the new multi attachment upload in the template, replace the
existing <code>input type="file"</code> with the following code in your
<filename>.tt</filename> template file:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
<label>[% Translate("Attachments") | html %]:</label>
<div class="Field">
[% INCLUDE "FormElements/AttachmentList.tt" %]
</div>
<div class="Clear"></div>
            ]]></programlisting>
        </para>
        <para>
            It is also necessary to remove the <code>IsUpload</code> variable and all
other <code>IsUpload</code> parts from the Perl module. Code parts like
following are not needed anymore:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $IsUpload = ( $ParamObject->GetParam( Param => 'AttachmentUpload' ) ? 1 : 0 );
            ]]></programlisting>
        </para>
        <para>
            Additional to that, the Attachment Layout Block needs to be replaced:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
$LayoutObject->Block(
    Name => 'Attachment',
    Data => $Attachment,
);
            ]]></programlisting>
        </para>
        <para>
            Replace it with this code:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
push @{ $Param{AttachmentList} }, $Attachment;
            ]]></programlisting>
        </para>
        <para>
            If the module where you want to integrate multi upload supports standard
templates, make sure to add a section to have a human readable file size
format right after the attachments of the selected template have been loaded
(see e.g. <literal>AgentTicketPhone</literal> for reference):
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
for my $Attachment (@TicketAttachments) {
    $Attachment->{Filesize} = $LayoutObject->HumanReadableDataSize(
        Size => $Attachment->{Filesize},
    );
}
            ]]></programlisting>
        </para>
        <para>
            When adding selenium unit tests for the modules you ported, please take a
look at <filename>Selenium/Agent/MultiAttachmentUpload.t</filename> for
reference.
        </para>
    </section>

    <section id="packge-porting-5-to-6-admin-modules">
        <title>Improvements to administration screens</title>

        <section id="packge-porting-5-to-6-breadcrumbs">
            <title>Add breadcrumbs to administration screens</title>
            <para>
                In OTRS 6, all admin modules should have a breadcrumb. The breadcrumb only
needs to be added on the <filename>.tt</filename> template file and should
be placed right after the h1 headline on top of the file. Additionally, the
headline should receive the class <code>InvisibleText</code> to make it only
<emphasis>visible</emphasis> for screen readers.
            </para>
            <programlisting format="linespecific"><![CDATA[
<div class="MainBox ARIARoleMain LayoutFixedSidebar SidebarFirst">
    <h1 class="InvisibleText">[% Translate("Name of your module") | html %]</h1>
[% BreadcrumbPath = [
        {
            Name => Translate('Name of your module'),
        },
    ]
%]
[% INCLUDE "Breadcrumb.tt" Path = BreadcrumbPath %]
...
            ]]></programlisting>
            <para>
                Please make sure to add the correct breadcrumb for all levels of your admin
module (e.g. <literal>Subaction</literal>s):
            </para>
            <programlisting format="linespecific"><![CDATA[
[% BreadcrumbPath = [
        {
            Name => Translate('Module Home Screen'),
            Link => Env("Action"),
        },
        {
            Name => Translate("Some Subaction"),
        },
    ]
%]

[% INCLUDE "Breadcrumb.tt" Path = BreadcrumbPath %]
                ]]></programlisting>
        </section>

        <section id="package-porting-5-to-6-saveandcontinue">
            <title>Add <emphasis>Save</emphasis> and <emphasis>Save and finish</emphasis>
buttons to administration screens</title>
            <para>
                Admin modules in OTRS 6 should not only have a <emphasis>Save</emphasis>
button, but also a <emphasis>Save and finish</emphasis>
button. <emphasis>Save</emphasis> should leave the user on the same edit
page after saving, <emphasis>Save and finish</emphasis> should lead back to
the overview of the entity the user is currently working on. Please see
existing OTRS admin screens for reference.
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
<div class="Field SpacingTop SaveButtons">
    <button class="Primary CallForAction" id="SubmitAndContinue" type="submit" value="[% Translate("Save") | html %]"><span>[% Translate("Save") | html %]</span></button>
    [% Translate("or") | html %]
    <button class="Primary CallForAction" id="Submit" type="submit" value="[% Translate("Save") | html %]"><span>[% Translate("Save and finish") | html %]</span></button>
    [% Translate("or") | html %]
    <a href="[% Env("Baselink") %]Action=[% Env("Action") %]"><span>[% Translate("Cancel") | html %]</span></a>
</div>
                ]]></programlisting>
            </para>
        </section>
    </section>

    <section id="packge-porting-5-to-6-configuration-files">
        <title>Migrate configuration files</title>

        <section id="package-porting-5-to-6-XML-config-file-format">
            <title>XML configuration file format</title>
            <para>
                OTRS 6 uses a new <link linkend="xml-config">XML configuration file
format</link> and the location of configuration files moved from
<filename>Kernel/Config/Files</filename> to
<filename>Kernel/Config/Files/XML</filename>.  To convert existing XML
configuration files to the new format and location, you can use the
following tool that is part of the OTRS framework:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
bin/otrs.Console.pl Dev::Tools::Migrate::ConfigXMLStructure --source-directory Kernel/Config/Files
Migrating configuration XML files...
Kernel/Config/Files/Calendar.xml -> Kernel/Config/Files/XML/Calendar.xml... Done.
Kernel/Config/Files/CloudServices.xml -> Kernel/Config/Files/XML/CloudServices.xml... Done.
Kernel/Config/Files/Daemon.xml -> Kernel/Config/Files/XML/Daemon.xml... Done.
Kernel/Config/Files/Framework.xml -> Kernel/Config/Files/XML/Framework.xml... Done.
Kernel/Config/Files/GenericInterface.xml -> Kernel/Config/Files/XML/GenericInterface.xml... Done.
Kernel/Config/Files/ProcessManagement.xml -> Kernel/Config/Files/XML/ProcessManagement.xml... Done.
Kernel/Config/Files/Ticket.xml -> Kernel/Config/Files/XML/Ticket.xml... Done.

Done.
                ]]></programlisting>
            </para>
        </section>

        <section id="package-porting-5-to-6-perl-config-file-format">
            <title>Perl configuration file format</title>
            <para>
                OTRS 6 speeds up configuration file loading by dropping support for the old
configuration format (1)  that just used sequential Perl code and had to be
run by <literal>eval</literal> and instead enforcing the new package-based
format (1.1) for Perl configuration files.  OTRS 6+ can only load files with
this format, please make sure to convert any custom developments to it (see
<filename>Kernel/Config/Files/ZZZ*.pm</filename> for examples). Every Perl
configuration file needs to contain a package with a
<literal>Load()</literal> method.
            </para>
            <para>
                In the past, Perl configuration files were sometimes misused as an autoload
mechanism to override code in existing packages. This is not necessary any
more as OTRS 6 features a dedicated <literal>Autoload</literal>
mechanism. Please see <filename>Kernel/Autoload/Test.pm</filename> for a
demonstration on how to use this mechanism to add a method in an existing
file.
            </para>
        </section>
    </section>

    <section id="package-porting-5-to-6-perldoc-structure">
        <title>Perldoc structure changed</title>
        <para>
            The structure of POD in Perl files was slightly improved and should be
adapted in all files. POD is now also enforced to be syntactically correct.
        </para>
        <para>
            What was previously called <literal>SYNOPSIS</literal> is now changed to
<literal>DESCRIPTION</literal>, as a synopsis typically provides a few
popular code usage examples and not a description of the module itself.  An
additional synopsis can be provided, of course. Here's how an example:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
=head1 NAME

Kernel::System::ObjectManager - Central singleton manager and object instance generator

=head1 SYNOPSIS

# In toplevel scripts only!
local $Kernel::OM = Kernel::System::ObjectManager->new();

# Everywhere: get a singleton instance (and create it, if needed).
my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

# Remove singleton objects and all their dependencies.
$Kernel::OM->ObjectsDiscard(
    Objects            => ['Kernel::System::Ticket', 'Kernel::System::Queue'],
);

=head1 DESCRIPTION

The ObjectManager is the central place to create and access singleton OTRS objects (via C<L</Get()>>)
as well as create regular (unmanaged) object instances (via C<L</Create()>>).

            ]]></programlisting>
        </para>
        <para>
            In case the <literal>DESCRIPTION</literal> does not add any value to the
line in the <literal>NAME</literal> section, it should be rewritten or
removed altogether.
        </para>
        <para>
            The second important change is that functions are now documented as
<literal>=head2</literal> instead of the previously used
<literal>=item</literal>.
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
=head2 Get()

Retrieves a singleton object, and if it not yet exists, implicitly creates one for you.

my $ConfigObject = $Kernel::OM->Get('Kernel::Config');

# On the second call, this returns the same ConfigObject as above.
my $ConfigObject2 = $Kernel::OM->Get('Kernel::Config');

=cut

sub Get { ... }
            ]]></programlisting>
        </para>
        <para>
            These changes lead to an improved online API documentation as can be seen in
the ObjectManager documentation for <ulink
url="http://otrs.github.io/doc/api/otrs/5.0/Perl/Kernel/System/ObjectManager.pm.html">OTRS
5</ulink> and <ulink
url="http://otrs.github.io/doc/api/otrs/6.0/Perl/Kernel/System/ObjectManager.pm.html">OTRS
6</ulink>.
        </para>
    </section>

    <section id="package-porting-javascript-templating-improvements">
        <title>Improvements to templating and working with JavaScript</title>

        <section id="package-porting-5-to-6-javascript-refactor">
            <title>JavaScript removed from templates</title>
            <para>
                With OTRS 6, all JavaScript - especially located in
<literal>JSOnDocumentComplete</literal> blocks - is removed from template
files and moved to JavaScript files instead. Only in very rare conditions
JavaScript needs to be placed within template files. For all other
occurrences, place the JS code in module-specific JavaScript files. An
<literal>Init()</literal> method within such a JavaScript file is executed
automatically on file load (for the initialization of event bindings etc.)
if you register the JavaScript file at the OTRS application. This is done by
executing <literal>Core.Init.RegisterNamespace(TargetNS,
'APP_MODULE');</literal> at the end of the namespace declaration within the
JavaScript file.
            </para>
        </section>

        <section id="package-porting-5-to-6-richtext-template">
            <title>Template files for rich text editor removed</title>
            <para>
                Along with the refactoring of the JavaScript within template files (see
above), the template files for the rich text editor
(<literal>RichTextEditor.tt</literal> and
<literal>CustomerRichTextEditor.tt</literal>)  were removed as they are no
longer necessary.
            </para>
            <para>
                Typically, these template files were included in the module-specific
template files within a block:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
[% RenderBlockStart("RichText") %]
[% InsertTemplate("RichTextEditor.tt") %]
[% RenderBlockEnd("RichText") %]
                ]]></programlisting>
            </para>
            <para>
                This is no longer needed and can be removed. Instead of calling this block
from the Perl module, it is now necessary to set the needed rich text
parameters there. Instead of:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$LayoutObject->Block(
    Name => 'RichText',
    Data => \%Param,
);
                ]]></programlisting>
            </para>
            <para>
                you now have to call:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$LayoutObject->SetRichTextParameters(
    Data => \%Param,
);
                ]]></programlisting>
            </para>
            <para>Same rule applies for customer interface. Remove RichText blocks from
<filename>CustomerRichTextEditor.tt</filename> and apply following code
instead:</para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$LayoutObject->CustomerSetRichTextParameters(
    Data => \%Param,
);
                ]]></programlisting>
            </para>
        </section>

        <section id="package-porting-5-to-6-javascript-translations">
            <title>Translations in JavaScript files</title>
            <para>
                Adding translatable strings in JavaScript was quite difficult in OTRS. The
string had to be translated in Perl or in the template and then sent to the
JavaScript function. With OTRS 6, translation of strings is possible
directly in the JavaScript file. All other workarounds, especially blocks in
the templates only for translating strings, should be removed.
            </para>
            <para>
                Instead, the new JavaScript translation namespace
<literal>Core.Language</literal> should be used to translate strings
directly in the JS file:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
Core.Language.Translate('The string to translate');
                ]]></programlisting>
            </para>
            <para>
                It is also possible to handover JS variables to be replaced in the string
directly:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
Core.Language.Translate('The %s to %s', 'string', 'translate');
                ]]></programlisting>
            </para>
            <para>
                Every <literal>%s</literal> is replaced by the variable given as extra
parameter. The number of parameters is not limited.
            </para>
        </section>

        <section id="package-porting-5-to-6-javascript-handover">
            <title>Handover data from Perl to JavaScript</title>
            <para>
                To achieve template files without JavaScript code, some other workarounds
had to be replaced with an appropriate solution. Besides translations, also
the handover of data from Perl to JavaScript has been a problem in OTRS. The
workaround was to add a JavaScript block in the template in which JavaScript
variables were declared and filled with template tags based on data handed
over from Perl to the template.
            </para>
            <para>
                The handover process of data from Perl to JavaScript is now much easier in
OTRS 6. To send specific data as variable from Perl to JavaScript, one only
has to call a function on Perl-side. The data is than automatically
available in JavaScript.
            </para>
            <para>
                In Perl you only have to call:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
$Self->{LayoutObject}->AddJSData(
    Key   => 'KeyToBeAvailableInJS',
    Value => $YourData,
);
                ]]></programlisting>
            </para>
            <para>
                The <literal>Value</literal> parameter is automatically converted to a JSON
object and can also contain complex data.
            </para>
            <para>
                In JavaScript you can get the data with:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
Core.Config.Get('KeyToBeAvailableInJS');
            ]]></programlisting>
            </para>
            <para>
                This replaces all workarounds which need to be removed when porting a module
to OTRS 6, because JavaScript in template files is now only allowed in very
rare conditions (see above).
            </para>
        </section>

        <section id="package-porting-5-to-6-javascript-templates">
            <title>HTML templates for JavaScript</title>
            <para>
                OTRS 6 exposes new JavaScript template API via
<literal>Core.Template</literal> class. You can use it in your JavaScript
code in a similar way as you use <literal>TemplateToolkit</literal> from
Perl code.
            </para>
            <para>
                Here's an example for porting existing <literal>jQuery</literal> based code
to new template API:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
var DivID = 'MyDiv',
    DivText = 'Hello, world!';

$('<div />').addClass('CSSClass')
    .attr('id', DivID)
    .text(DivText)
    .appendTo('body');
                ]]></programlisting>
            </para>
            <para>
                First, make sure to create a new template file under
<literal>Kernel/Output/JavaScript/Templates/Standard</literal> folder. In
doing this, you should keep following in mind:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Create a subfolder with name of your <literal>Module</literal>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            You may reuse any existing subfolder structure but only if it makes sense
for your component (e.g. <literal>Agent/MyModule/</literal> or
<literal>Agent/Admin/MyModule/</literal>).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Use <literal>.html.tmpl</literal> as extension for template file.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Name templates succinctly and clearly in order to avoid confusion
(i.e. good: <literal>Agent/MyModule/SettingsDialog.html.tmpl</literal>, bad:
<literal>Agent/SettingsDialogTemplate.html.tmpl</literal>).
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Then, add your HTML to the template file, making sure to use placeholders
for any variables you might need:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
<div id="{{ DivID }}" class="CSSClass">
    {{ DivText | Translate }}
</div>
                ]]></programlisting>
            </para>
            <para>
                Then, just get rendered HTML by calling
<literal>Core.Template.Render</literal> method with template path (without
extension) and object containing variables for replacement:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
var DivHTML = Core.Template.Render('Agent/MyModule/SettingsDialog', {
    DivID: 'MyDiv',
    DivText: 'Hello, world!'
});

$(DivHTML).appendTo('body');
                ]]></programlisting>
            </para>
            <para>
                Internally, <literal>Core.Template</literal> uses Nunjucks engine for
parsing templates. Essentially, any valid Nunjucks syntax is supported,
please see <ulink
url="https://mozilla.github.io/nunjucks/templating.html">their
documentation</ulink> for more information.
            </para>
            <para>
                Here are some tips:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>
                            You can use <literal>| Translate</literal> filter for string translation to
current language.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            All <literal>{{ VarName }}</literal> variable outputs are HTML escaped by
default. If you need to output some existing HTML, please use <literal>|
safe</literal> filter to bypass escaping.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Use <literal>| urlencode</literal> for encoding URL parameters.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Complex structures in replacement object are supported, so feel free to pass
arrays or hashes and iterate over them right from template. For example,
look at <literal>{% for %}</literal> syntax in <ulink
url="https://mozilla.github.io/nunjucks/templating.html#for"> Nunjucks
documentation</ulink>.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>

    </section>

    <section id="package-porting-5-to-6-user-permissions">
        <title>Checking user permissions</title>
        <para>
            Before OTRS 6, user permissions were stored in the session and passed to the
<code>LayoutObject</code> as attributes, which were then in turn accessed to
determine user permissions like <code>if
($LayoutObject->{'UserIsGroup[admin]'}) { ... }</code>.
        </para>
        <para>
            With OTRS 6, permissions are no longer stored in the session and also not
passed to the <code>LayoutObject</code>. Please switch your code to calling
<code>PermissionCheck()</code> on <code>Kernel::System::Group</code> (for
agents) or <code>Kernel::System::CustomerGroup</code> (for
customers). Here's an example:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $HasPermission = $Kernel::OM->Get('Kernel::System::Group')->PermissionCheck(
UserID    => $UserID,
GroupName => $GroupName,
Type      => 'move_into',
);
            ]]></programlisting>
        </para>
    </section>

    <section id="package-porting-5-to-6-ticket-api">
        <title>Ticket API changes</title>

        <section id="package-porting-5-to-6-ticket-api-ticketget">
            <title><literal>TicketGet()</literal></title>
            <para>
                For OTRS 6, all extensions need to be checked and ported from
<literal>$Ticket{SolutionTime}</literal> to
<literal>$Ticket{Closed}</literal> if <literal>TicketGet()</literal> is
called with the <literal>Extended</literal> parameter (see bug<ulink
url="http://bugs.otrs.org/show_bug.cgi?id=11872">#11872</ulink>).
            </para>
            <para>
                Additionally, the database column <literal>ticket.create_time_unix</literal>
was removed, and likewise the value <literal>CreateTimeUnix</literal> from
the <literal>TicketGet()</literal> result data.  Please use the value
<literal>Created</literal> (database column
<literal>ticket.create_time</literal>) instead.
            </para>
        </section>

        <section id="package-porting-5-to-6-ticket-api-linkobject-events">
            <title><literal>LinkObject</literal> Events</title>
            <para>
                In OTRS 6, old ticket-specific <literal>LinkObject</literal> events have
been dropped:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>TicketSlaveLinkAdd</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>TicketSlaveLinkDelete</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>TicketMasterLinkDelete</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Any event handlers listening on these events should be ported to two new
events instead:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>LinkObjectLinkAdd</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>LinkObjectLinkDelete</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                These new events will be triggered any time a link is added or deleted by
<literal>LinkObject</literal>, regardless of the object
type. <literal>Data</literal> parameter will contain all information your
event handlers might need for further processing, e.g.:
            </para>
            <para>
                <variablelist>
                    <varlistentry>
                        <term><literal>SourceObject</literal></term>
                        <listitem>
                            <para>
                                Name of the link source object (e.g. <literal>Ticket</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>SourceKey</literal></term>
                        <listitem>
                            <para>
                                Key of the link source object (e.g. <literal>TicketID</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>TargetObject</literal></term>
                        <listitem>
                            <para>
                                Name of the link target object (e.g. <literal>FAQItem</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>TargetKey</literal></term>
                        <listitem>
                            <para>
                                Key of the link target object (e.g. <literal>FAQItemID</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Type</literal></term>
                        <listitem>
                            <para>
                                Type of the link (e.g. <literal>ParentChild</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>State</literal></term>
                        <listitem>
                            <para>
                                State of the link (<literal>Valid</literal> or
<literal>Temporary</literal>).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                With these new events in place, any events specific for custom
<literal>LinkObject</literal> module implementations can be dropped, and all
event handlers ported to use them instead. Since source and target object
names are provided in the event itself, it would be trivial to make them run
only in specific situations.
            </para>
            <para>
                To register your event handler for these new events, make sure to add a
registration in the configuration, for example:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
<!-- OLD STYLE -->
<ConfigItem Name="LinkObject::EventModulePost###1000-SampleModule" Required="0" Valid="1">
    <Description Translatable="1">Event handler for sample link object module.</Description>
    <Group>Framework</Group>
    <SubGroup>Core::Event::Package</SubGroup>
    <Setting>
        <Hash>
            <Item Key="Module">Kernel::System::LinkObject::Event::SampleModule</Item>
            <Item Key="Event">(LinkObjectLinkAdd|LinkObjectLinkDelete)</Item>
            <Item Key="Transaction">1</Item>
        </Hash>
    </Setting>
</ConfigItem>

<!-- NEW STYLE -->
<Setting Name="LinkObject::EventModulePost###1000-SampleModule" Required="0" Valid="1">
    <Description Translatable="1">Event handler for sample link object module.</Description>
    <Navigation>Core::Event::Package</Navigation>
    <Value>
        <Hash>
            <Item Key="Module">Kernel::System::LinkObject::Event::SampleModule</Item>
            <Item Key="Event">(LinkObjectLinkAdd|LinkObjectLinkDelete)</Item>
            <Item Key="Transaction">1</Item>
        </Hash>
    </Value>
</Setting>
                ]]></programlisting>
            </para>
        </section>
    </section>

    <section id="package-porting-5-to-6-article-api">
        <title>Article API changes</title>
        <para>
            In OTRS 6, changes to Article API have been made, in preparations for new
<emphasis>Omni Channel</emphasis> infrastructure.
        </para>

        <section id="otrs6-article-methods">
            <title>Meta Article API</title>
            <para>
                Article object now provides top-level article functions that do not involve
back-end related data.
            </para>
            <para>
                Following methods related to articles have been moved to
<literal>Kernel::System::Ticket::Article</literal> object:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                          <para><literal>ArticleFlagSet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleFlagDelete()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleFlagGet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleFlagsOfTicketGet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleAccountedTimeGet()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleAccountedTimeDelete()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleSenderTypeList()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleSenderTypeLookup()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>SearchStringStopWordsFind()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>SearchStringStopWordsUsageWarningActive()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                If you are referencing any of these methods via
<literal>Kernel::System::Ticket</literal> object in your code, please switch
to Article object and use it instead. For example:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
    my $ArticleObject = $Kernel::OM->Get('Kernel::System::Ticket::Article');

    my %ArticleSenderTypeList = $ArticleObject->ArticleSenderTypeList();
                ]]></programlisting>
            </para>
            <para>
                New <literal>ArticleList()</literal> method is now provided by the article
object, and can be used for article listing and locating. This method
implements filters and article numbering and returns article meta data only
as an ordered list. For example:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my @Articles = $ArticleObject->ArticleList(
    TicketID             => 123,
    CommunicationChannel => 'Email',            # optional, to limit to a certain CommunicationChannel
    SenderType           => 'customer',         # optional, to limit to a certain article SenderType
    IsVisibleForCustomer => 1,                  # optional, to limit to a certain visibility
    OnlyFirst            => 1,                  # optional, only return first match, or
    OnlyLast             => 1,                  # optional, only return last match
);
                ]]></programlisting>
            </para>
            <para>
                Following methods related to articles have been dropped all-together. If you
are using any of them in your code, please evaluate possibility of
alternatives.
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                          <para>
                              <literal>ArticleFirstArticle()</literal> (use <literal>ArticleList(
OnlyFirst => 1)</literal> instead)
                          </para>
                    </listitem>
                    <listitem>
                          <para>
                              <literal>ArticleLastCustomerArticle()</literal> (use <literal>ArticleList(
SenderType => 'customer', OnlyLast => 1)</literal> or similar)
                          </para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleCount()</literal> (use <literal>ArticleList()</literal>
instead)</para>
                    </listitem>
                    <listitem>
                          <para>
                              <literal>ArticlePage()</literal> (reimplemented in
<literal>AgentTicketZoom</literal>)
                          </para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleTypeList()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleTypeLookup()</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleIndex()</literal> (use <literal>ArticleList()</literal>
instead)</para>
                    </listitem>
                    <listitem>
                          <para><literal>ArticleContentIndex()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                To work with article data please use new article backend API. To get correct
backend object for an article, please use:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                          <para><literal>BackendForArticle(%Article)</literal></para>
                    </listitem>
                    <listitem>
                          <para><literal>BackendForChannel( ChannelName => $ChannelName )</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <literal>BackendForArticle()</literal> returns the correct back end for a
given article, or the invalid back end, so that you can always expect a back
end object instance that can be used for chain-calling.
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my $ArticleBackendObject = $ArticleObject->BackendForArticle( TicketID => 42, ArticleID => 123 );
                ]]></programlisting>
            </para>
            <para>
                <literal>BackendForChannel()</literal> returns the correct back end for a
given communication channel.
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my $ArticleBackendObject = $ArticleObject->BackendForChannel( ChannelName => 'Email' );
                ]]></programlisting>
            </para>
        </section>

        <section id="package-porting-5-to-6-article-backend-api">
            <title>Article Backend API</title>
            <para>
                All other article data and related methods have been moved to separate
backends. Every communication channel now has a dedicated backend API that
handles article data and can be used to manipulate it.
            </para>
            <para>
                OTRS 6 Free ships with some default channels and corresponding backends:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Email (equivalent to old <literal>email</literal> article types)</para>
                    </listitem>
                    <listitem>
                        <para>Phone (equivalent to old <literal>phone</literal> article types)</para>
                    </listitem>
                    <listitem>
                        <para>Internal (equivalent to old <literal>note</literal> article types)</para>
                    </listitem>
                    <listitem>
                        <para>Chat (equivalent to old <literal>chat</literal> article types)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <note>
                <para>
                    While chat article backend is available in OTRS 6 Free, it is only utilized
when system has a valid <emphasis role="bold">OTRS Business
Solution™</emphasis> installed.
                </para>
            </note>
            <para>
                Article data manipulation can be managed via following backend methods:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>ArticleCreate()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleUpdate()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleGet()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleDelete()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                All of these methods have dropped article type parameter, which must be
substituted for <literal>SenderType</literal> and
<literal>IsVisibleForCustomer</literal> parameter combination. In addition,
all these methods now also require <literal>TicketID</literal> and
<literal>UserID</literal> parameters.
            </para>
            <note>
                <para>
                    Since changes in article API are system-wide, any code using the old API
must be ported for OTRS 6.  This includes any web service definitions which
leverage these methods directly via GenericInterface for example. They will
need to be re-assessed and adapted to provide all required parameters to the
new API during requests and manage subsequent responses in new format.
                </para>
            </note>
            <para>
                Please note that returning hash of <literal>ArticleGet()</literal> has
changed, and some things (like ticket data) might be missing. Utilize
parameters like <literal>DynamicFields => 1</literal> and <literal>RealNames
=> 1</literal> to get more information.
            </para>
            <para>
                In addition, attachment data is not returned any more, please use
combination of following methods from the article backends:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><literal>ArticleAttachmentIndex()</literal></para>
                    </listitem>
                    <listitem>
                        <para><literal>ArticleAttachment()</literal></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                Note that <literal>ArticleAttachmentIndex()</literal> parameters and
behavior has changed. Instead of old strip parameter use combination of new
<literal>ExcludePlainText</literal>, <literal>ExcludeHTMLBody</literal> and
<literal>ExcludeInline</literal>.
            </para>
            <para>
                As an example, here is how to get all article and attachment data in the
same hash:
            </para>
            <para>
                <programlisting format="linespecific"><![CDATA[
my @Articles = $ArticleObject->ArticleList(
    TicketID => $TicketID,
);

ARTICLE:
for my $Article (@Articles) {

    # Make sure to retrieve backend object for this specific article.
    my $ArticleBackendObject = $ArticleObject->BackendForArticle( %{$Article} );

    my %ArticleData = $ArticleBackendObject->ArticleGet(
        %{$Article},
        DynamicFields => 1,
        UserID        => $UserID,
    );
    $Article = \%ArticleData;

    # Get attachment index (without attachments).
    my %AtmIndex = $ArticleBackendObject->ArticleAttachmentIndex(
        ArticleID => $Article->{ArticleID},
        UserID    => $UserID,
    );
    next ARTICLE if !%AtmIndex;

    my @Attachments;
    ATTACHMENT:
    for my $FileID ( sort keys %AtmIndex ) {
        my %Attachment = $ArticleBackendObject->ArticleAttachment(
            ArticleID => $Article->{ArticleID},
            FileID    => $FileID,
            UserID    => $UserID,
        );
        next ATTACHMENT if !%Attachment;

        $Attachment{FileID} = $FileID;
        $Attachment{Content} = encode_base64( $Attachment{Content} );

        push @Attachments, \%Attachment;
    }

    # Include attachment data in article hash.
    $Article->{Atms} = \@Attachments;
}
                ]]></programlisting>
            </para>
        </section>
        <section id="package-porting-5-to-6-article-search-index">
            <title>Article Search Index</title>
            <para>
                To make article indexing more generic, article backends now provide
information necessary for properly indexing article data. Index will be
created similar to old <literal>StaticDB</literal> mechanism and stored in a
dedicated article search table.
            </para>
            <para>
                Since now every article backend can provide search on arbitrary number of
article fields, use <literal>BackendSearchableFieldsGet()</literal> method
to get information about them. This data can also be used for forming
requests to <literal>TicketSearch()</literal> method. Coincidentally, some
<literal>TicketSearch()</literal> parameters have changed their name to also
include article backend information, for example:
            </para>
            <para>
                <informaltable>
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry>Old parameter</entry>
                                <entry>New parameter</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><literal>From</literal></entry>
                                <entry><literal>MIMEBase_From</literal></entry>
                            </row>
                            <row>
                                <entry><literal>To</literal></entry>
                                <entry><literal>MIMEBase_To</literal></entry>
                            </row>
                            <row>
                                <entry><literal>Cc</literal></entry>
                                <entry><literal>MIMEBase_Cc</literal></entry>
                            </row>
                            <row>
                                <entry><literal>Subject</literal></entry>
                                <entry><literal>MIMEBase_Subject</literal></entry>
                            </row>
                            <row>
                                <entry><literal>Body</literal></entry>
                                <entry><literal>MIMEBase_Body</literal></entry>
                            </row>
                            <row>
                                <entry><literal>AttachmentName</literal></entry>
                                <entry><literal>MIMEBase_AttachmentName</literal></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>
                Additionally, article search indexing will be done in an async call now, in
order to off-load index calculation to a separate task. While this is fine
for production systems, it might create new problems in certain situations,
e.g. unit tests. If you are manually creating articles in your unit test,
but expect it to be searchable immediately after created, make sure to
manually call the new <literal>ArticleSearchIndexBuild()</literal> method on
article object.
            </para>
        </section>
    </section>
    <section id="package-porting-5-to-6-sysconfig-changes">
        <title>SysConfig API changes</title>
        <para>
            Note that in OTRS 6 SysConfig API was changed, so you should check if the
methods are still existing.  For example,
<literal>ConfigItemUpdate()</literal> is removed. To replace it you should
use combination of the following methods:
        </para>
        <para>
            <itemizedlist>
                <listitem>
                    <para><literal>SettingLock()</literal></para>
                </listitem>
                <listitem>
                    <para><literal>SettingUpdate()</literal></para>
                </listitem>
                <listitem>
                    <para><literal>ConfigurationDeploy()</literal></para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            In case that you want to update a configuration setting during a
<literal>CodeInstall</literal> section of a package, you could use
<literal>SettingsSet()</literal>.  It does all previously mentioned steps
and it can be used for multiple settings at once.
        </para>
        <note>
            <para>Do not use <literal>SettingSet()</literal> in the SysConfig GUI itself.</para>
        </note>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $Success = $SysConfigObject->SettingsSet(
    UserID   => 1,                                      # (required) UserID
    Comments => 'Deployment comment',                   # (optional) Comment
    Settings => [                                       # (required) List of settings to update.
        {
            Name                   => 'Setting::Name',  # (required)
            EffectiveValue         => 'Value',          # (optional)
            IsValid                => 1,                # (optional)
            UserModificationActive => 1,                # (optional)
        },
        ...
    ],
);
            ]]></programlisting>
        </para>
    </section>
    <section id="package-porting-5-to-6-linkobject-changes">
        <title><literal>LinkObject</literal> API changes</title>
        <para>
            Note that <literal>LinkObject</literal> was slightly modified in the OTRS 6
and methods <literal>LinkList()</literal> and
<literal>LinkKeyList()</literal> might return different result if
<literal>Direction</literal> parameter is used. Consider changing
<literal>Direction</literal>.
        </para>
        <para>
            Old code:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $LinkList = $LinkObject->LinkList(
    Object    => 'Ticket',
    Key       => '321',
    Object2   => 'FAQ',
    State     => 'Valid',
    Type      => 'ParentChild',
    Direction => 'Target',
    UserID    => 1,
);
            ]]></programlisting>
        </para>
        <para>
            New code:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
my $LinkList = $LinkObject->LinkList(
    Object    => 'Ticket',
    Key       => '321',
    Object2   => 'FAQ',
    State     => 'Valid',
    Type      => 'ParentChild',
    Direction => 'Source',
    UserID    => 1,
);
            ]]></programlisting>
        </para>
    </section>
    <section id="package-porting-5-to-6-postmaster-filter-communication-log">
        <title>Communication Log support for additional PostMaster Filters</title>
        <para>
            As part of email handling improvements for OTRS 6, a new logging mechanism
was added to OTRS 6, exclusively used for incoming and outgoing
communications. All PostMaster filters were enriched with this new <link
linkend="log-mechanism-communication-log">Communication Log</link> API,
which means any additional filters coming with packages should also leverage
the new log feature.
        </para>
        <para>
            If your package implements additional PostMaster filters, make sure to get
acquainted with <link linkend="log-mechanism-communication-log">API usage
instructions</link>. Also, you can get an example of how to implement this
logging mechanism by looking the code in the
<literal>Kernel::System::PostMaster::NewTicket</literal>.
        </para>
    </section>

    <section id="package-porting-5-to-6-process-mailqueue-for-ut">
        <title>Process MailQueue for unit tests</title>
        <para>
            As part of email handling improvements for OTRS 6, all emails are now sent
asynchronously, that means they are saved in a queue for future processing.
        </para>
        <para>
            To the unit tests that depend on emails continue to work properly is
necessary to force the processing of the email queue.
        </para>
        <para>
            Make sure to start with a clean queue:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                $MailQueueObject->Delete();
            ]]></programlisting>
        </para>
        <para>
            If for some reason you can't clean completely the queue, e.g. selenium unit
tests, just delete the items created during the tests:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                my %MailQueueCurrentItems = map { $_->{ID} => $_ } @{ $MailQueueObject->List() || [] };

                my $Items = $MailQueueObject->List();
                MAIL_QUEUE_ITEM:
                for my $Item ( @{$Items} ) {
                    next MAIL_QUEUE_ITEM if $MailQueueCurrentItems{ $Item->{ID} };
                    $MailQueueObject->Delete(
                        ID => $Item->{ID},
                    );
                }
            ]]></programlisting>
        </para>
        <para>
            Process the queue after the code that you expect to send emails:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                my $QueueItems      = $MailQueueObject->List();
                for my $Item ( @{$QueueItems} ) {
                    $MailQueueObject->Send( %{$Item} );
                }
            ]]></programlisting>
        </para>
        <para>
            Or process only the ones created during the tests:
        </para>
        <para>
            <programlisting><![CDATA[
                my $MailQueueObject = $Kernel::OM->Get('Kernel::System::MailQueue');
                my $QueueItems      = $MailQueueObject->List();
                MAIL_QUEUE_ITEM:
                for my $Item ( @{$QueueItems} ) {
                    next MAIL_QUEUE_ITEM if $MailQueueCurrentItems{ $Item->{ID} };
                    $MailQueueObject->Send( %{$Item} );
                }
            ]]></programlisting>
        </para>
        <para>
            Depending on your case, you may need to clean the queue after or before
processing it.
        </para>
    </section>

    <section id="package-porting-5-to-6-agentticketzoom-widget-handling">
        <title>Widget Handling in Ticket Zoom Screen</title>
        <para>
            The widgets in the ticket zoom screen have been improved to work in a more
generic way. With OTRS 6, it is now possible to add new widgets for the
ticket zoom screen via the SysConfig. It is possible to configure the used
module, the location of the widget (e.g. Sidebar) and if the content should
be loaded synchronously (default) or via AJAX.
        </para>
        <para>
            Here is an example configuration for the default widgets:
        </para>
        <para>
            <programlisting format="linespecific"><![CDATA[
<Setting Name="Ticket::Frontend::AgentTicketZoom###Widgets###0100-TicketInformation" Required="0" Valid="1">
    <Description Translatable="1">AgentTicketZoom widget that displays ticket data in the side bar.</Description>
    <Navigation>Frontend::Agent::View::TicketZoom</Navigation>
    <Value>
        <Hash>
            <Item Key="Module">Kernel::Output::HTML::TicketZoom::TicketInformation</Item>
            <Item Key="Location">Sidebar</Item>
        </Hash>
    </Value>
</Setting>
<Setting Name="Ticket::Frontend::AgentTicketZoom###Widgets###0200-CustomerInformation" Required="0" Valid="1">
    <Description Translatable="1">AgentTicketZoom widget that displays customer information for the ticket in the side bar.</Description>
    <Navigation>Frontend::Agent::View::TicketZoom</Navigation>
    <Value>
        <Hash>
            <Item Key="Module">Kernel::Output::HTML::TicketZoom::CustomerInformation</Item>
            <Item Key="Location">Sidebar</Item>
            <Item Key="Async">1</Item>
        </Hash>
    </Value>
</Setting>
            ]]></programlisting>
        </para>
        <note>
            <para>
                With this change, the template blocks in the widget code have been removed,
so you should check if you use the old widget blocks in some output filters
via <literal>Frontend::Template::GenerateBlockHooks</literal> functionality,
and implement it in the new fashion.
            </para>
        </note>
    </section>
</section>
